% ================= Terminal-Style Template mit Box-zu-Box-Farbverlauf =================
\documentclass[11pt,a4paper,oneside]{article}

% ---------- Fonts & Math (Xe/Lua) ----------
\usepackage{fontspec}
\usepackage{unicode-math}

% --- Hauptschrift ---
\setmainfont{IBM Plex Sans}
%\setsansfont{IBM Plex Sans}

% --- Mathematik ---
\setmathfont{Libertinus Math}

% --- Monospace / Terminal ---
% VT323 für Retro-Terminal-Look
%\setmonofont{VT323}[Scale=1.1]
%\setmonofont{Fira Code}[Scale=1.1]
%\setmonofont{JetBrains Mono}[Scale=1.1]
%\setmonofont{Source Code Pro}[Scale=1.1]


% ---------- Packages ----------
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{pagecolor}
\usepackage{tikz}
\usepackage{hyperref}
\usepackage[most]{tcolorbox}
\tcbuselibrary{skins,breakable,listings}
\usepackage{titlesec}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{courier}
\usepackage[ngerman]{babel}

% ---------- Layout ----------
\geometry{left=26mm,right=26mm,top=28mm,bottom=30mm}
\pagestyle{fancy}
\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\fancyhead[L]{\textsf{\small PRIN — Q3}}
\fancyhead[R]{\textsf{\small Ferdinand-Braun Schule}}
\fancyfoot[C]{\scriptsize Leistungskurs Praktische Informatik Q3 \; • \; \thepage}



% -------------------- Farben (fein abgestuft, subtiler Fluss) --------------------
\definecolor{PageBG}{RGB}{17,11,31}             % sehr dunkler Hintergrund
\definecolor{TextCream}{RGB}{246,241,234}       % creme / sehr hell

\definecolor{AccentBlue}{RGB}{76,104,150}       % akademisches Blau (unverändert)
\definecolor{AccentViolet}{RGB}{105,77,145}     % seriöses Violett (unverändert)

% Hint: mehr ins violett/pinke ziehen (Hauch von Fuchsia)
\definecolor{AccentMagenta}{RGB}{140,60,120}       % violett-pink (sanfter Übergang)

% Magenta: rötlicher, dichter, aber nicht grell
\definecolor{AccentHint}{RGB}{170,40,60}     % rötliches Magenta (mehr Rotanteil)

% Elegantes Rot: orientiert sich am bisherigen "AccentHint" (tiefes Weinrot)
\definecolor{AccentRed}{RGB}{120,10,25}         % elegantes Weinrot / tiefes Rot

\definecolor{BoxBackground}{RGB}{15,9,27}       % Box-Hintergrund
\definecolor{MarginalGray}{RGB}{150,150,160}    % Rand-Datum

% ---------- Terminal-Farben ----------
\definecolor{TermBG}{RGB}{10,12,14}
\definecolor{TermText}{RGB}{236,240,241}
\definecolor{MatrixGreen}{RGB}{57,255,20}
\definecolor{MatrixGreenDim}{RGB}{35,180,12}
\definecolor{MatrixGreenDeep}{RGB}{18,110,6}
\definecolor{Steel}{RGB}{80,90,100}
\definecolor{AccentWarn}{RGB}{200,40,40}

%\pagecolor{TermBG}
\pagecolor{black!93}
\color{TermText}

% ================= Palette: Schritte von Grün -> Rot =================
% Du kannst hier mehr Stufen erzeugen (Step0 .. StepN)
\definecolor{Step0}{RGB}{57,255,20}   % sattes Grün
\definecolor{Step1}{RGB}{110,230,20}
\definecolor{Step2}{RGB}{170,200,25}
\definecolor{Step3}{RGB}{210,160,30}
\definecolor{Step4}{RGB}{230,120,35}
\definecolor{Step5}{RGB}{240,80,40}
\definecolor{Step6}{RGB}{220,50,40}
\definecolor{Step7}{RGB}{200,30,40}   % Rot-ähnlich

% ---------- Sequenzzähler ----------
\newcounter{boxseq}
\setcounter{boxseq}{-1} % beginnt bei 0 nach erstem \stepcounter

% ---------- Makro: nächste Palette-Farben als NAMEN setzen ----------
% Wir setzen drei Makros:
% \CurrentAccentName         = z.B. "Step3"
% \CurrentAccentDarkName     = z.B. "Step3!70!black"
% \CurrentAccentFrameName    = z.B. "Step3!50!black"
\makeatletter
\newcommand{\nextboxcolors}{%
	\stepcounter{boxseq}%
	% Anzahl der Palette-Schritte minus 1 (hier 7 => max index 7)
	\ifcase\value{boxseq}%
	\def\CurrentAccentName{Step0}%
	\or\def\CurrentAccentName{Step1}%
	\or\def\CurrentAccentName{Step2}%
	\or\def\CurrentAccentName{Step3}%
	\or\def\CurrentAccentName{Step4}%
	\or\def\CurrentAccentName{Step5}%
	\or\def\CurrentAccentName{Step6}%
	\else\def\CurrentAccentName{Step7}%
	\fi
	% dunklere Varianten als Strings (werden von xcolor zur Laufzeit interpretiert)
	\edef\CurrentAccentDarkName{\CurrentAccentName!70!black}%
	\edef\CurrentAccentFrameName{\CurrentAccentName!50!black}%
}
\makeatother

% ================= tcolorbox Basis-Stil (Terminal-Look) =================
\tcbset{
	termbase/.style={
		enhanced,
		breakable,
		boxrule=0.9pt,
		colback=TermBG,
		colupper=TermText,
		arc=1mm,
		boxsep=5pt,
		left=14pt,right=14pt,top=12pt,bottom=12pt,
		before skip=8pt, after skip=8pt,
		attach boxed title to top left={yshift=-0.1mm-\tcboxedtitleheight/2, xshift=9mm},
		boxed title style={
			arc=1mm, left=6pt,right=6pt,top=3pt,bottom=3pt, boxrule=0pt
		},
		fonttitle=\sffamily\bfseries\small,
		title after break=\vspace{4pt}
	}
}

% ================= Umgebung-Implementierungen (mit eigenen Zählern) =================
% Wir verwenden eigene LaTeX-Zähler (statt tcolorbox auto counter), damit wir
% vorher \nextboxcolors aufrufen können und die Palette-Makros gesetzt sind.

% ----- Theorem -----
\newcounter{theorem}[section]
\renewcommand{\thetheorem}{\thesection.\arabic{theorem}}
\newenvironment{theorem}[1]{%
	\refstepcounter{theorem}%
	\nextboxcolors%
	\begin{tcolorbox}[termbase,
		colframe=\CurrentAccentFrameName,
		boxed title style={interior style={left color=\CurrentAccentName, right color=\CurrentAccentDarkName}},
		title={Theorem~\thetheorem: #1}]%
	}{\end{tcolorbox}}

% ----- Beispiel -----
\newcounter{beispiel}[section]
\renewcommand{\thebeispiel}{\thesection.\arabic{beispiel}}
\newenvironment{beispiel}[1]{%
	\refstepcounter{beispiel}%
	\nextboxcolors%
	\begin{tcolorbox}[termbase,
		colframe=\CurrentAccentFrameName,
		boxed title style={interior style={left color=\CurrentAccentName, right color=\CurrentAccentDarkName}},
		title={Beispiel~\thebeispiel: #1}]%
	}{\end{tcolorbox}}

% ----- Aufgabe -----
\newcounter{aufgabe}[section]
\renewcommand{\theaufgabe}{\thesection.\arabic{aufgabe}}
\newenvironment{aufgabe}[1]{%
	\refstepcounter{aufgabe}%
	\nextboxcolors%
	\begin{tcolorbox}[termbase,
		colframe=\CurrentAccentFrameName,
		boxed title style={interior style={left color=\CurrentAccentName, right color=\CurrentAccentDarkName}},
		title={Aufgabe~\theaufgabe: #1}]%
	}{\end{tcolorbox}}

% ----- Lösung (verwendet eigenen Zähler, kann optional an Aufgabe gekoppelt werden) -----
\newcounter{loesung}[section]
\renewcommand{\theloesung}{\thesection.\arabic{loesung}}
\newenvironment{loesung}[1]{%
	\refstepcounter{loesung}%
	\nextboxcolors%
	\begin{tcolorbox}[termbase,
		colframe=\CurrentAccentFrameName,
		boxed title style={interior style={left color=\CurrentAccentName, right color=\CurrentAccentDarkName}},
		title={Lösung~\theloesung: #1}]%
	}{\end{tcolorbox}}

% ----- Hinweis / Info -----
\newenvironment{infobox}{%
	\nextboxcolors%
	\begin{tcolorbox}[termbase,
		colframe=\CurrentAccentFrameName,
		boxed title style={interior style={left color=\CurrentAccentName, right color=\CurrentAccentDarkName}},
		title={Hinweis}]%
	}{\end{tcolorbox}}

% ----- Terminal (Listing only) -----
\newenvironment{terminal}[1]{%
	\nextboxcolors%
	\begin{tcolorbox}[termbase,
		colframe=\CurrentAccentFrameName,
		boxed title style={interior style={left color=\CurrentAccentName, right color=\CurrentAccentDarkName}},
		title={Terminal: #1},
		listing only,
		listing options={
			basicstyle=\ttfamily\small, columns=fullflexible,
			showstringspaces=false, tabsize=2, breaklines=true,
			backgroundcolor=\color{TermBG},
			keywordstyle=\color{MatrixGreen},
			commentstyle=\color{Steel},
			stringstyle=\color{MatrixGreenDim},
			frame=none, numbersep=8pt, numbers=none
		}]%
	}{\end{tcolorbox}}

% ================= Sonstiges =================
\lstdefinestyle{darkterm}{
	basicstyle=\ttfamily\small, columns=fullflexible,
	showstringspaces=false, tabsize=2, breaklines=true,
	backgroundcolor=\color{TermBG},
	keywordstyle=\color{MatrixGreen},
	commentstyle=\color{Steel},
	stringstyle=\color{MatrixGreenDim},
	frame=single, rulecolor=\color{MatrixGreenDeep!80!black},
	xleftmargin=0pt, numbersep=8pt, numbers=left,
	numberstyle=\tiny\color{Steel}
}
\lstset{style=darkterm}

\newcommand{\lessondate}[1]{\noindent\hfill\textcolor{Steel}{\textsc{#1}}\\[6pt]}


% ==================== Feines Titelblatt ====================
\newcommand{\MakeArtTitle}[4]{%
	\begin{titlepage}
		\vspace*{18mm}
		\begin{center}
			%\begin{tikzpicture}
			%	\fill[AccentViolet!85!black] (0,0) circle (1.2cm);
			%	\fill[PageBG] (0.15,0.15) circle (0.95cm);
			%	\draw[line width=1pt,color=AccentBlue] (0,0) circle (1.35cm);
			%	\node[white] at (0,0) {\sffamily\bfseries\Large M};
			%\end{tikzpicture}
			\vspace{12mm}
			%{\Huge\bfseries\sffamily\color{TextCream} #1 \par}
			{\huge\color{TextCream} #1 \par}
			\vspace{6mm}
			{\Large\itshape\color{AccentBlue!50} #2 \par}
			\vspace{10mm}
			{\Large\scshape\color{TextCream} #3 \par}
			\vspace{6mm}
			{\small\color{MarginalGray} #4 \par}
			%\vfill
			\vspace{5mm}
			{\small\color{MarginalGray} \today \par}
			%\vspace{12mm}
			%\begin{tikzpicture}
			%	\draw[line width=1.2pt,color=AccentViolet!80!black] (-6,0) -- (6,0);
			%	\draw[line width=0.45pt,color=AccentBlue!60!black] (-6,-0.3) -- (6,-0.3);
			%\end{tikzpicture}
		\end{center}
		\vspace{7.5cm}
		\centering
		%\includegraphics[width=0.75\textwidth]{2.png} % Logo einfügen (Pfad anpassen)
	\end{titlepage}
}



% ================= Dokumentbeginn =================
\begin{document}
	
		% Titelblatt
	\MakeArtTitle{
		Leistungskurs Praktische Q3 Hessen}
	{Skript}
	{Shamsher Singh Kalsi}
	{Berufliches Gymnasium — Ferdinand-Braun Schule \\ Kursleiter: Herr Sebastian Stolz}
	
	\tableofcontents
	\bigskip
	
	\newpage
	
	\section{Einführung}
	\lessondate{05.09.2025}
	
	
	
	\begin{aufgabe}{Serielle Kommunikation}
		\begin{enumerate}
			\item Beantworte folgende Fragen schriftlich:
			\begin{itemize}
				\item An welcher Stelle spielt die serielle Kommunikation heutzutage eine Rolle?
				\item Erkläre die Begriffe: Startbit, Datenbit, Stoppbit.
				\item Ein PC sendet den Buchstaben 'A' mit 1 Startbit, 8 Datenbits, 1 Stoppbit.
				Skizziere das resultierende Bitmuster
				\item Welche Parameter müssen Sender und Empfänger bei RS232 vorab
				gemeinsam einstellen?
				\item Warum reicht ein einziger Draht für die Übertragung?
			\end{itemize}
			\item Aufgabe 2 – Serielle Kommunikation (RS232) in Java mit Hilfe eines Emulators
			\begin{itemize}
				\item Warum brauchen Sender und Empfänger die gleiche Baudrate?
				\item Was passiert, wenn der Sender schneller schreibt als der Empfänger lesen kann? Welche Lösungen gibt es für dieses Problem?
			\end{itemize}
		\end{enumerate}
	\end{aufgabe}
	
	\newpage
	
	\begin{loesung}{Serielle Kommunikation}
		\begin{enumerate}
			\item Beantworte folgende Fragen schriftlich:
			\begin{itemize}
				\item Serielle Kommunikation wird heute noch in eingebetteten Systemen, Industrieanlagen, Messgeräten und auch beim Serverzugriff (Konsolenport) genutzt, da sie einfach, robust und für kurze Distanzen ausreichend ist.
				
				\item \textbf{Startbit:} signalisiert Beginn eines Zeichens (logisch 0) und dient zur Synchronisation.  
				\textbf{Datenbits:} eigentliche Nutzinformation, meist 8 Bit, LSB zuerst.  
				\textbf{Stoppbit:} beendet die Übertragung (logisch 1), Leitung geht in Idle-Zustand.
				
				\item Beispiel: Der Buchstabe \texttt{A} hat den ASCII-Wert \texttt{0x41} = \texttt{01000001}.  
				Übertragung (LSB zuerst) mit 1 Startbit und 1 Stopbit:  
				\[
				\underbrace{1}_{\text{Idle}} \; 
				\underbrace{0}_{\text{Start}} \;
				1\,0\,0\,0\,0\,0\,1\,0 \;
				\underbrace{1}_{\text{Stop}} \;
				1
				\]
				
				\item Sender und Empfänger müssen sich bei RS232 vorab einigen auf: Baudrate, Datenbits, Parität, Stoppbits, sowie ggf. Art der Flusskontrolle.
				
				\item Ein einzelner Draht genügt pro Richtung, weil Bits nacheinander mit fester Baudrate gesendet werden; Start- und Stoppbits übernehmen die Synchronisation. Für echte Vollduplex-Kommunikation sind jedoch zwei Leitungen (Tx/Rx) plus Masse üblich.
			\end{itemize}
			
			\item Aufgabe 2 – Serielle Kommunikation (RS232) in Java mit Hilfe eines Emulators
			\begin{itemize}
				\item Beide Seiten brauchen dieselbe Baudrate, da es kein separates Taktsignal gibt. Unterschiedliche Baudraten führen zu falscher Bitinterpretation.
				
				\item Wenn der Sender schneller schreibt als der Empfänger liest, läuft dessen Puffer über und Daten gehen verloren.  
				Lösungen: Hardware-Flowcontrol (RTS/CTS), Software-Flowcontrol (XON/XOFF), größere FIFO-Puffer oder Protokolle mit Bestätigung (ACK/NACK).
			\end{itemize}
		\end{enumerate}
	\end{loesung}
	
	\lstset{language=Java, basicstyle=\ttfamily\small, numbers=left, frame=single}
	\begin{lstlisting}
		import com.fazecast.jSerialComm.SerialPort;
		public class Sender {
			public static void main(String[] args) throws Exception {
				SerialPort sp = SerialPort.getCommPort("COM5");
				sp.setBaudRate(9600);
				sp.openPort();
				sp.getOutputStream().write("Hallo, COM6\n".getBytes());
				sp.closePort();
			}
		}
	\end{lstlisting}
	
	\newpage
	
	\begin{center}
			\begin{tikzpicture}[yscale=0.8, xscale=0.8]
			% Bitfolge: Idle(1), Start(0), Data: 1 0 0 0 0 0 1 0, Stop(1), Idle(1)
			\foreach [count=\n] \b in {1,0,1,0,0,0,0,0,1,0,1,1} {
				\draw (\n-1,0) rectangle ++(1,1) node[midway]{\b};
			}
			% Beschriftung
			\node[below] at (0.5,-0.2) {Idle};
			\node[below] at (1.5,-0.2) {Start};
			\node[below] at (5.5,-0.2) {Datenbits};
			\node[below] at (10.5,-0.2) {Stop};
		\end{tikzpicture}
	\end{center}
		
		
	\newpage
	
	\lessondate{09.09.2025}\\
	
	\begin{aufgabe}{Steuerung eines Mikroprozessors mit der seriellen Schnittstelle}
		\begin{enumerate}
			\item Schreibe ein (Python-)Programm, welches einen selbst gewählten Sensor auf einem Raspberry-PI oder einem Arduino steuert.
			\item Erweitere das Programm so, dass es über eine serielle Schnittstelle angesprochen werden kann. Emuliere die serielle Schnittstelle mit Hilfe von Software oder nutze einen RS232/TTL Wandler mit MAX3232
			\item Nutze die Klasse "Serial" aus dem Moodle-Kurs, um von einem Laptop oder PC mit einem Java-Programm über die serielle Schnittstelle den Sensor zu steuern.
		\end{enumerate}
	\end{aufgabe}
	
	\begin{loesung}
		
	\end{loesung}
	
	\newpage
	
	
	\begin{aufgabe}{Steuerung eines Mikroprozessors mit der seriellen Schnittstelle}
		\begin{enumerate}
			\item Schreibe ein Python-Programm, das einen Sensor bzw. ein Aktor-Device auf einem Raspberry Pi steuert.
			
			\begin{lstlisting}[language=Python, caption={Raspberry Pi: LED-Steuerung + serielle Steuerung (pySerial + gpiozero)}]
				# requirements: gpiozero, pyserial
				# python3 script that controls an LED via gpiozero and listens on a serial port for commands
				from gpiozero import LED
				import serial
				import time
				
				LED_PIN = 17
				SERIAL_PORT = '/dev/ttyUSB0'  # auf RPi: USB-Serial oder /dev/ttyAMA0 etc.
				BAUD = 9600
				
				led = LED(LED_PIN)
				ser = serial.Serial(SERIAL_PORT, BAUD, timeout=1)  # pySerial: blocking read behaviour depends on timeout
				
				def handle_line(line):
				line = line.strip()
				if line.upper() == 'LED ON':
				led.on()
				ser.write(b'OK\n')
				elif line.upper() == 'LED OFF':
				led.off()
				ser.write(b'OK\n')
				elif line.upper() == 'STATUS':
				ser.write(('ON\n' if led.is_lit else 'OFF\n').encode())
				else:
				ser.write(b'ERR Unknown command\n')
				
				try:
				while True:
				raw = ser.readline()   # read a line terminated by newline; depends on timeout. (pySerial)
				if raw:
				handle_line(raw.decode('utf-8', errors='ignore'))
				time.sleep(0.01)
				finally:
				ser.close()
				led.off()
			\end{lstlisting}
			
			Dieses Python-Beispiel verwendet `gpiozero` zur einfachen GPIO-Abstraktion auf dem Raspberry Pi und `pySerial` für die serielle Schnittstelle; `pySerial`'s Lese-/Timeout-Verhalten ist dokumentiert und beeinflusst, wie `readline()` blockiert. :contentReference[oaicite:1]{index=1}
			
			\item Ein Arduino-Beispiel, das serielle Kommandos entgegennimmt und einen digitalen Pin steuert:
			\begin{lstlisting}[language=C, caption={Arduino: Serial command handler}]
				// Arduino sketch: listens on Serial, toggles digital pin, replies with status
				const int LED_PIN = 13;
				
				void setup() {
					pinMode(LED_PIN, OUTPUT);
					Serial.begin(9600); // init serial
				}
				
				void loop() {
					if (Serial.available() > 0) { // number of bytes available
						String cmd = Serial.readStringUntil('\n'); // read until newline
						cmd.trim();
						if (cmd == "LED ON") {
							digitalWrite(LED_PIN, HIGH);
							Serial.println("OK");
						} else if (cmd == "LED OFF") {
							digitalWrite(LED_PIN, LOW);
							Serial.println("OK");
						} else if (cmd == "STATUS") {
							Serial.println(digitalRead(LED_PIN) ? "ON" : "OFF");
						} else {
							Serial.println("ERR");
						}
					}
				}
			\end{lstlisting}
			
			Die Arduino-API stellt `Serial.available()` und `Serial.read()` / `readStringUntil()` bereit; `available()` gibt die Anzahl bereits empfangener Bytes an, `read()` liefert das nächste Byte oder -1, wenn nichts da ist — das ist der übliche Pattern für nicht-blockierende Abfragen auf Arduino. :contentReference[oaicite:2]{index=2}
			
			\item Java-Client mit der Klasse \texttt{Serial} (wie in deinem Moodle-Skript beschrieben). Das Beispiel öffnet den Port, schickt einen String, liest eine Antwortzeile und parst eine Zahl mit \texttt{Double.parseDouble(...)}:
			\begin{lstlisting}[language=Java, caption={Java: Steuerprogramm (Nutzungsbeispiel der in der Aufgabenstellung beschriebenen Serial-Klasse)}]
				// Beispiel: Java-Client (konform mit der Serial-Klassen-API aus der Aufgabenstellung)
				public class SerialController {
					public static void main(String[] args) {
						Serial s = new Serial("COM5", 9600, 8, 1, 0); // parity 0 = none, falls so erwartet
						if (!s.open()) {
							System.err.println("Port konnte nicht geöffnet werden");
							return;
						}
						// Beispiel: sende Kommando, warte auf Antwort als Zeile
						s.write("STATUS\n");
						String reply = s.readLine(); // blockiert bis Zeile komplett
						System.out.println("Reply: " + reply);
						// parsing numeric reply example
						try {
							double val = Double.parseDouble(reply.trim());
							System.out.println("Parsed value: " + val);
						} catch (NumberFormatException e) {
							System.out.println("No numeric reply: " + reply);
						}
						s.close();
					}
				}
			\end{lstlisting}
			
			In Java wandelt `Double.parseDouble(String)` einen String in einen primitiven `double` um; das ist die standardisierte Methode in der Java-API. Für ereignisgesteuertes Lesen oder Low-Level-Buffers sind Bibliotheken wie jSerialComm nützlich, die sowohl blockierende als auch non-blocking Modi und Event-Listener unterstützen. :contentReference[oaicite:3]{index=3}
			
			\item Hinweis zur Pegelwandlung und Verbindung: Wenn du echte RS-232-Signale anschließt (±V-Level) musst du einen Pegelwandler wie den MAX3232 verwenden; TTL-UART-Pins (3.3 V/5 V) dürfen nicht direkt an RS-232-Level angeschlossen werden. Der MAX3232 bietet Treiber/Empfänger und die nötigen Charge-Pump-Kondensatoren. :contentReference[oaicite:4]{index=4}
			
			\item Bonus: Protokoll mit Längenpräfix und Erkennung unvollständiger Übertragung.
			
			Implementiere auf Senderseite: sende zuerst ASCII-Länge, dann `':'`, dann die Nachricht (z. B. `12:Hello World!`), oder sende ein 2-Byte Binary-Length-Prefix gefolgt von Rohbytes. Auf Empfängerseite: lese zunächst bis `':'`, parse die Länge, dann lies exakt diese Anzahl Bytes; falls weniger Bytes empfangen wurden, warte weiter oder melde „incomplete“ — mit `read(b,len)` kannst du gezielt eine bestimmte Anzahl von Bytes lesen und prüfen, wie viele tatsächlich geliefert wurden. Diese Technik verhindert das Vermischen von Nachrichten bei Stream-Orientierung. :contentReference[oaicite:5]{index=5}
			
		\end{enumerate}
	\end{aufgabe}
	
	
	\newpage
	
	
	\begin{theorem}{Fundamentaler Satz}
		Inhalt des Theorems ...
	\end{theorem}
	
	\begin{beispiel}{Erstes Beispiel}
		Dieses Beispiel illustriert den Satz.
	\end{beispiel}
	
	\begin{aufgabe}{Rechenaufgabe}
		Bearbeite folgende Aufgabe ...
	\end{aufgabe}
	
	\begin{loesung}{zur Aufgabe}
		Hier die Lösungsschritte ...
	\end{loesung}
	
	\begin{infobox}
		Ein kurzer Hinweis.
	\end{infobox}
	
	\begin{terminal}{Beispielcode}
		echo "Hallo Welt"
		ls -la
	\end{terminal}
	
\end{document}
